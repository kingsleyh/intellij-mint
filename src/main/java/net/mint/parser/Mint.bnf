{
    parserClass='net.mint.MintParser'

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    elementTypeHolderClass='net.mint.psi.MintElementTypes'

    elementTypeClass='net.mint.psi.MintElementType'
    tokenTypeClass='net.mint.psi.MintTokenType'

    psiClassPrefix='Mint'
    psiImplClassSuffix='Impl'
    psiPackage='net.mint.psi'
    psiImplPackage='net.mint.psi.impl'

    generateTokenAccessors=false

    tokens = [
        LEFT_BRACE =                         "{"
        RIGHT_BRACE =                        "}"
        LEFT_PAREN =                         "("
        RIGHT_PAREN =                        ")"
        LEFT_BRACKET =                       "["
        RIGHT_BRACKET =                      "]"
        PIPE =                               "|"
        DOT =                                "."
        COMMA =                              ","
        EQUAL =                              "="
        EQUAL_EQUAL =                        "=="
        BACKSLASH =                          "\\\\"
        RIGHT_ARROW =                        "=>"
        NOT_EQUAL =                          "!="
        NOT =                                "!"
        LEFT_ARROW =                         "<="
        LESS =                               "<"
        GREATER_EQUAL =                      ">="
        GREATER =                            ">"
        PLUS_EQUAL =                         "+="
        PLUS =                               "+"
        MINUS_GREATER =                      "->"
        FUNCTION_PIPE =                      "|>"
        MINUS =                              "-"
        TIMES =                              "*"
        DIVIDENTE =                          "/"
        MODULO =                             "%"
        ARRAY =                              "[]"
        NAMESPACE =                          "::"
        COLON =                              ":"
        AND_AND =                            "&&"
        AND =                                "&"
        OR_OR =                              "||"
        HASH =                               "#"
        DOLLAR =                             "$"
        QUESTION =                           "?"
        SEMI =                               ";"
        CASE =                               "case"
        DO =                                 "do"
        TRY =                                "try"
        ELSE =                               "else"
        IF =                                 "if"
        TRUE =                               "true"
        FALSE =                              "false"
        AS =                                 "as"
        ENCODE =                             "encode"
        DECODE =                             "decode"
        USING =                              "using"
        PROPERTY =                           "property"
        RECORD =                             "record"
        CATCH =                              "catch"
        COMPONENT =                          "component"
        MODULE =                             "module"
        STORE =                              "store"
        STATE =                              "state"
        PROPERTY =                           "property"
        NEXT =                               "next"
        WHERE =                              "where"
        WITH =                               "with"
        FINALLY                              "finally"
        WHEN =                               "when"
        FUN =                                "fun"
        GET =                                "get"
        USE =                                "use"
        ENUM =                               "enum"
        VOID =                               "void"
        PROVIDER =                           "provider"
        ROUTES =                             "routes"
        LINE_COMMENT =                       'regexp:/\*.*'
        STRING_LITERAL =                     'regexp:("([^\"\\]|\\.)*")'
        NUMBER_LITERAL =                     'regexp:(\+|\-)?(0b[01_]+|0o[0-7_]+|0x[a-fA-f\d_]+|[\d_]+)(\.[\d_]+)?(e[-+]?[\d_]+)?(_?(i|f|u)(8|16|32|64))?'

        IDENT               = "regexp:\w+"
        space               = 'regexp:\s+'
    ]
}

mintFile ::= item_*

private item_ ::= (statements | expressions)

private compositeStatement ::= (statements | expressions)

private statements ::= statement [statements]

private expressions ::= expression [expressions]

statement ::=
  'component' itemType '{' [compositeStatement] '}'
| 'module' itemType '{' [compositeStatement] '}'
| 'store' itemType '{' [compositeStatement] '}'
| 'record' itemType '{' [recordItems] '}'
| 'routes' '{' [compositeStatement] '}'
| 'provider' itemType ':' itemType '{' [compositeStatement] '}'
| htmls

private keywords ::=
  'component'
 | 'module'
 | 'store'
 | 'record'
 | 'routes'
 | 'provider'
 | 'state'
 | 'property'
 | 'void'
 | 'encode'
 | 'decode'

private recordItems ::= recordItem [recordItems]

recordItem ::= IDENT ':' itemType ('using' STRING_LITERAL)? ','?

expression ::=
  mlhs '=' mrhs
  | arg

mlhs ::= mlhsItem ',' [mlhsItem (',' mlhsItem)*] [ '*' lhs] | '*' lhs

mlhsItem ::= lhs | '(' mlhs ')'

lhs ::=
   variable
   | primaries '[' [args] ']'
   | primaries '.' IDENT

mrhs ::= args [',' arg] | arg

private args ::= arg [',' args]

private arg ::=
   lhs '=' arg
  | lhs opAsgn arg
  | ('+' | '-'  | '*'  | '/'  | '%'  | '|'  | '^'
  | '&'  | '>'  | '>=' | '<'  | '<=' | '==' | '!=' | '=' | '|>'
  | '!'  | '&&' | '||') arg
  | primaries


private opAsgn ::= '+'|'-'|'*'|'/'|'%'

private primaries ::= primary [primaries]

private primary ::= '(' compositeStatement ')'
| recordAssignments
| literal
| variable
| '::' IDENT
| '[' [args] ']'
| '{' [args] '}'
| '[]'
| '()' ':'?
| '[' [args [',']] ']'
| function
| 'state' IDENT ':' itemType
| 'property' IDENT ':' itemType
| 'do' '{' [compositeStatement] '}'
| 'try' '{' [compositeStatement] '}'
| ('.' | '::') operation ['(' [callArgs] ')']
| 'next'
| 'catch'
| '=>'
| 'where'
| 'when'
| 'with'
| 'finally'
| useProvider
| 'void'
| 'decode' IDENT 'as' itemType
| 'encode'


useProvider ::=
  'use' itemType '{' [recordAssignments] '}'

private recordAssignments ::= recordAssignment [ ',' recordAssignments]

private recordAssignment ::= (IDENT '|')? IDENT '=' compositeStatement

//| 'if' expression 'then' compositeStatement ['elsif' expression 'then' compositeStatement] ['else' compositeStatement] 'end'
//| ('case'| 'select') [compositeStatement] 'when' whenArgs 'then' compositeStatement ['when' whenArgs 'then' compositeStatement] ['else' compositeStatement] 'end'

function ::=
    'fun' IDENT argDecl? ':' itemType '{' [compositeStatement] '}'
  | 'get' IDENT ':' itemType '{' [compositeStatement] '}'
  | '(' (IDENT ':' itemType)? ')' ':' itemType '=>' '{' [compositeStatement] '}'

argDecl ::= '(' argList ')' | '()' | argList

private itemParts ::= itemPart [itemParts]
private itemPart ::= IDENT ['.'] ['(' manyParts ')']

private manyParts ::= singlePart [manyParts]
private singlePart ::= itemPart [',']

itemType ::= itemParts

argList ::= IDENT ':' itemType (',' IDENT ':' itemType)*

private callArgs ::= args
//       | args [',' assocs] [',' '*' args] [',' '&' arg]
//       | assocs [',' '*' args] [',' '&' arg]
//       | '*' arg [',' '&' arg] | '&' arg


literal ::= (TRUE
       | FALSE
       | NUMBER_LITERAL
       | STRING_LITERAL)

variable ::= varName

varName ::= IDENT

private operation ::= IDENT ['!' | '?']


// HTML
private htmls ::= html [htmls]
html ::= tagOpen | tagEmpty | tagClose | mintTag

tagOpen ::= '<' tagName attrList? '>'
tagEmpty ::= '<' tagName attrList? '/' '>'
tagClose ::= '</' tagName '>'
mintTag ::= '<' '{' [compositeStatement] '}' '>'


attrList ::= (attr)*
attr ::= attrEmpty | attrUnquoted | attrSingleQuoted | attrDoubleQuoted

attrEmpty ::= attrName
attrUnquoted ::= attrName '=' IDENT
attrSingleQuoted ::= attrName '=' "'" IDENT "'"
attrDoubleQuoted ::= attrName '=' '"' IDENT '"'

tagName ::= IDENT
attrName ::= IDENT


